## JPA로 데이터베이스를 다뤄보자

**현재 운영을 진행하면서 MyBatis를 이용해 데이터베이스 쿼리를 작성한다.**

**즉, 실제 개발하는 시간보다 SQL을 다루는 시간이 더 많게 느껴진다는 것이다. **

**해당 문제는 객체지향 프로그래밍의 걸림돌이 된다.. 객체 모델링 보다는 테이블 모델링에 집중하게 되고...**



이를 해결하기 위해 즉,  관계형 데이터베이스를 이용해서 객체지향 프로그래밍을 할 수 있는 **JPA(자바 표준 ORM)이 나타나게 된다.**



**참고**

ibatis와 mybatis는 ORM이 아니고, SQL Mapper이다.

ORM은 **객체를 매핑하는 것**이고, SQL Mapper는 **쿼리를 매핑한다는 것**에 차이가 있다.



### JPA란,

현대 웹 애플리케이션에서는 관계형 데이터베이스가 필수적이다. Oracle, MySQL, MSSQL 등을 쓰지 않는 웹 애플리케이션이 거의 없으므로 **객체를 관계형 데이터베이스에서 관리하는 것**은 무엇보다 중요하다.

이 처럼, 관계형 데이터베이스가 중심이 되면서 모든 코드는 **SQL의 중심**이 되어 간다.

그로인해 개발자들은 CRUD SQL을 반복적으로 사용해야 한다.

이런 반복 작업에서 가장 큰 문제는 **패러다임 불일치**이다.



**패러다임 불일치**

- 관계형 데이터베이스는 어떻게 데이터를 저장할지 초점이 맞춰진 기술이다.
- 객체지향 프로그래밍 언어는 메시지를 기반으로 기능과 속성을 관리하는 기술이다.
- **결과적으로 관계형 데이터베이스와 객체지향 프로그래밍 언어는 사상이 다르므로, 같은 목표를 가질 수가 없는것이다.**



**객체 프로그래밍 언어의 소스를 확인해보자**

```java
User user = findUser();
Group group = user.getGroup();
```

**User(자식)와 Group(부모)은 누가봐도 부모-자식 관계임을 알 수 있다. -> User 본인이 속한 Group을 가져온다.**



**데이터베이스를 추가한 소스를 확인해보자**

```java
USer user = userDao.findUser();
Group group = groupDao.findGroup(user.getGroupId());
```

**User 따로, Group 따로 조회하게 되는 현상을 볼 수 있다.**



**즉, 상속 혹은 1:N 등의 다양한 객체 모델리을 데이터베이스로는 구현이 불가능하다는 것이다.**



이런 문제를 해결하기 위해 JPA가 나타났다.

**JPA는 관계형 데이터베이스와 객체지향 프로그래밍 언어을 중간에서 패러다임을 일치시켜준다**



**결과적으로, 개발자는 객체지향적으로 프로그래밍하고, JPA가 관계형 데이터베이스에 맞게 SQL을 대신 생성하여 실행하는 것이다.**

객체 중심으로 개발이 되므로 대규모 트래픽과 데이터를 가진 서비스에서는 JPA를 표준 기술로 자리 잡고 있다.